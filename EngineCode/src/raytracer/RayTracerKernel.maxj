package raytracer;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;

class RayTracerKernel extends Kernel {

	private static final DFEType dfechar = dfeUInt(8);
	private static final DFEType dfeuint = dfeUInt(32);
	private static final DFEType dfefloat = dfeFloat(8, 24);
	private static final DFEVectorType<DFEVar> vector3 = new DFEVectorType<DFEVar>(dfeFloat(8,24),3);
	private static final DFEVectorType<DFEVar> vector4 = new DFEVectorType<DFEVar>(dfeFloat(8,24),4);

	//ensure that triangles sizes are always a multiple of the memory burst width

	public static final DFEStructType triangle_t =
		new DFEStructType(
				DFEStructType.sft("v0", vector3),
				DFEStructType.sft("v1", vector3),
				DFEStructType.sft("v2", vector3)
			);

	public static final DFEStructType ray_t =
		new DFEStructType(
				DFEStructType.sft("origin", vector3),
				DFEStructType.sft("direction", vector3),
				DFEStructType.sft("padding", dfeUInt(64))
			);

	public static final DFEStructType result_t =
		new DFEStructType(
				DFEStructType.sft("ray", dfeuint),
				DFEStructType.sft("triangle", dfeuint)
			);

	public static int Triangles_In_Width_in_Bits = 384 * 8;
	public static int Triangles_Per_Tick = 10;

	public static int Rays_Per_Tick = 1;

	public static int Total_Output_Count = 0;

	public void AddConstantsToMaxFile(CustomManager manager)
	{
		manager.addMaxFileConstant("TriangleInWidthInBits", Triangles_In_Width_in_Bits);
	}

	protected List<DFEStruct> GetTriangles()
	{
		List<DFEStruct> triangles = new ArrayList<DFEStruct>();

		Triangles_Per_Tick = (int) Math.floor((float)Triangles_In_Width_in_Bits / (float)triangle_t.getTotalBits());

		DFEVar triangles_in = io.input("triangles_in", dfeRawBits(Triangles_In_Width_in_Bits));

		for(int i = 0; i < Triangles_Per_Tick; i++)
		{
			triangles.add(triangle_t.unpack(triangles_in.slice(i * triangle_t.getTotalBits(), triangle_t.getTotalBits())));
		}

		return triangles;
	}

	protected RayTracerKernel(KernelParameters parameters) throws Exception {
		super(parameters);


		DFEVar total_triangles = io.scalarInput("total_triangles", dfeUInt(32));
		DFEVar total_rays = io.scalarInput("total_rays", dfeUInt(32));

		CounterChain set_counters = control.count.makeCounterChain();
		DFEVar ray_offset = set_counters.addCounter(total_rays, Rays_Per_Tick);
		DFEVar triangle_offset = set_counters.addCounter(total_triangles, Triangles_Per_Tick);

		//get the ray set
		DFEStruct rays_in = io.input("rays_in", ray_t, triangle_offset.eq(0)); //only read a set of rays when the entire scene has been traversed

		//get the triangle set
		List<DFEStruct> triangles_in = GetTriangles();

		//perform the intersection tests
		for(int i = 0; i < triangles_in.size(); i++)
		{
			DFEStruct triangle = triangles_in[i];
			DFEVar result = PerformIntersectionTest(rays_in, triangle);

			DFEStruct result_struct = result_t.newInstance(this);
			result_struct["ray"] = (ray_offset + 0).cast(dfeuint);
			result_struct["triangle"] = (triangle_offset + i).cast(dfeuint);

			// prepare the outputs - each intersection test has its own buffered output which will be filled with only positive intersection results,
			// which will then be formatted and transmitted over PCIe downstream

			io.output("results_" + Integer.toString(Total_Output_Count), result_struct, result_t, result);
			Total_Output_Count++;
		}


		DFEVar complete = ray_offset.eq(total_rays - Rays_Per_Tick) & triangle_offset.eq(total_triangles - Triangles_Per_Tick);
		io.output("complete", complete, dfeBool());

	}

	//https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm

	DFEVar PerformIntersectionTest(DFEStruct ray, DFEStruct triangle) throws Exception
	{
		DFEVector<DFEVar> V1 = triangle["v0"];
		DFEVector<DFEVar> V2 = triangle["v1"];
		DFEVector<DFEVar> V3 = triangle["v2"];

		DFEVector<DFEVar> D = ray["direction"];
		DFEVector<DFEVar> O = ray["origin"];

		DFEVector<DFEVar> e1, e2;  //Edge1, Edge2
		DFEVector<DFEVar> P, Q, T;
		DFEVar det, inv_det, u, v;
		DFEVar t;

		DFEVar valid = constant.var(true);

		//Find vectors for two edges sharing V1
		e1 = KernelVectorMath.subtract(V2, V1);
		e2 = KernelVectorMath.subtract(V3, V1);

		//Begin calculating determinant - also used to calculate u parameter
		P = KernelVectorMath.cross(D, e2);

		//if determinant is near zero, ray lies in plane of triangle
		det = KernelVectorMath.dot(e1, P);

		//NOT CULLING

		//dot product is 0 meaning ray is parallel with plane of triangle so invalidate result
		valid = valid & (det.neq(0));

		inv_det = 1.f / det;

		//calculate distance from V1 to ray origin
		T = KernelVectorMath.subtract(O, V1);

		//Calculate u parameter and test bound
		u = KernelVectorMath.dot(T, P) * inv_det;
		//The intersection lies outside of the triangle
		valid = valid & (u > 0.f) & (u <= 1.f);

		//Prepare to test v parameter
		Q = KernelVectorMath.cross(T, e1);

		//Calculate V parameter and test bound
		v = KernelVectorMath.dot(D, Q) * inv_det;
		//The intersection lies outside of the triangle
		valid = valid & (v > 0.f) & (u + v <= 1.f);

		t = KernelVectorMath.dot(e2, Q) * inv_det;

		valid = valid & (t > 0);

		return valid;
	}

}
